\documentclass[12pt]{article} 
\usepackage{graphics}
\usepackage{setspace}

% the following is to get inch margins on a letter-size paper
\setlength{\topmargin}{0pt}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.0in}
\setlength{\footskip}{0.5in}
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.5in}

\doublespacing
\begin{document}
\title{A Java Wrapper For Embarresingly Parallel Programs}
\author{Jacob Schwartz}
\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat
cupidatat non proident, sunt in culpa qui officia deserunt mollit anim
id est laborum.
\end{abstract}


\section{Introduction}

This is just a test. This is just a test (a line break follows)\\
this is just a test.

\begin{itemize}
\item History of parallelism and java?
\item Discuss embarresingly parallel (2 paragraphs)
\item What we are going to do (1 page, one paragraph about problem)
\item Summary of results
\end{itemize}

\section{Background}

BACKGROUND ON WORK WITH DAVE. INTRO TO KAKS

Instead of attempting to rewrite the preexisting program, blah. Trying to
parallelize the serial KaKs Calculator program would have presented several
problems: introducing bugs, breaking the KaKs algorithm, and the learning curve
of C++ threading. With such a short time before results were needed, a different
approach was necessary. A simple Java program was written to break up the input
and spawn threads that would run BLANKS's KaKs Calculator. When the input was
calculated, the contents of the output files was concatenated together to
produce a final input. MORE?

The KaKs Calculator is not the only embarresingly parallel program that has the
potential to take several days to run on a data set. In fact, there are several
embarresingly parallel programs in the biological sciences. TALK ABOUT OTHER
PROGRAMS HERE. With this multitude of applications that would benefit from
parallelism, it was obvious that the wrapper program has potential outside of
this project.

TALK ABOUT PAPER HERE. AND MAYBE THE POWERPOINT TOO.

The original wrapper was also written very quickly due to the impending
deadline. In this version of the wrapper, several components are being added.
First off, there is a wizard style menu that will allow the end-user to select
not only the program that wish to use, but also to manage other settings for the
run. A new IO class splits the input and merges the output more 
efficiently. Lastly, in order to look at how well the wrapper performs, 
the threads keep their own statstics. These statstics will not only be used to 
find potential enhancements but also will help end-users of the wrapper
determine whether their use of the wrapper is efficient.

\section{Proposed Solution}

Break down the components. Have a UML diagram here first

splitter

merger

wizard

Lastly, the worker threads will keep records during the execution of a set of 
work. The threads records its uptime and the number of pieces of work it
executes on. Also, the runtime for each piece of work is recorded. These will be
used by the end user to determine if their run is ideal or if they may need to
change some settings to make it work faster next time. The statistics can also
give the developers of the wrapper an idea on what can be implemented in order
make it as fast as possible for a user.

\section{Results}

Tables charts, etc

\section{Conclusion}

Future work \\
if we had a do over\\

current plans for improvement

\begin{thebibliography}{1}

\bibitem{aodv}
C. Perkins,  E. Belding-Royer, and  S. Das, ``\emph{Ad hoc On-Demand
Distance Vector (AODV) Routing},'' IETF RFC 3561, July 2003.

\end{thebibliography}

\end{document}
